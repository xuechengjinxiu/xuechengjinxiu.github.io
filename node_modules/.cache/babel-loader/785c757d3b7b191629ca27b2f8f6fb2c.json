{"remainingRequest":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/vuetify/lib/components/VSparkline/VSparkline.js","dependencies":[{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/vuetify/lib/components/VSparkline/VSparkline.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport _defineProperty from \"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.array.fill\";\nimport _typeof from \"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.number.constructor\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Mixins\nimport Colorable from \"../../mixins/colorable\"; // Utilities\n\nimport mixins from \"../../util/mixins\";\nimport { genPoints, genBars as _genBars } from \"./helpers/core\";\nimport { genPath as _genPath } from \"./helpers/path\";\nexport default mixins(Colorable).extend({\n  name: 'VSparkline',\n  inheritAttrs: false,\n  props: {\n    autoDraw: Boolean,\n    autoDrawDuration: {\n      type: Number,\n      default: 2000\n    },\n    autoDrawEasing: {\n      type: String,\n      default: 'ease'\n    },\n    autoLineWidth: {\n      type: Boolean,\n      default: false\n    },\n    color: {\n      type: String,\n      default: 'primary'\n    },\n    fill: {\n      type: Boolean,\n      default: false\n    },\n    gradient: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    gradientDirection: {\n      type: String,\n      validator: function validator(val) {\n        return ['top', 'bottom', 'left', 'right'].includes(val);\n      },\n      default: 'top'\n    },\n    height: {\n      type: [String, Number],\n      default: 75\n    },\n    labels: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    labelSize: {\n      type: [Number, String],\n      default: 7\n    },\n    lineWidth: {\n      type: [String, Number],\n      default: 4\n    },\n    padding: {\n      type: [String, Number],\n      default: 8\n    },\n    showLabels: Boolean,\n    smooth: {\n      type: [Boolean, Number, String],\n      default: false\n    },\n    type: {\n      type: String,\n      default: 'trend',\n      validator: function validator(val) {\n        return ['trend', 'bar'].includes(val);\n      }\n    },\n    value: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    width: {\n      type: [Number, String],\n      default: 300\n    }\n  },\n  data: function data() {\n    return {\n      lastLength: 0\n    };\n  },\n  computed: {\n    parsedPadding: function parsedPadding() {\n      return Number(this.padding);\n    },\n    parsedWidth: function parsedWidth() {\n      return Number(this.width);\n    },\n    parsedHeight: function parsedHeight() {\n      return parseInt(this.height, 10);\n    },\n    parsedLabelSize: function parsedLabelSize() {\n      return parseInt(this.labelSize, 10) || 7;\n    },\n    totalHeight: function totalHeight() {\n      var height = this.parsedHeight;\n      if (this.hasLabels) height += parseInt(this.labelSize, 10) * 1.5;\n      return height;\n    },\n    totalWidth: function totalWidth() {\n      var width = this.parsedWidth;\n      if (this.type === 'bar') width = Math.max(this.value.length * this._lineWidth, width);\n      return width;\n    },\n    totalValues: function totalValues() {\n      return this.value.length;\n    },\n    _lineWidth: function _lineWidth() {\n      if (this.autoLineWidth && this.type !== 'trend') {\n        var totalPadding = this.parsedPadding * (this.totalValues + 1);\n        return (this.parsedWidth - totalPadding) / this.totalValues;\n      } else {\n        return parseFloat(this.lineWidth) || 4;\n      }\n    },\n    boundary: function boundary() {\n      if (this.type === 'bar') return {\n        minX: 0,\n        maxX: this.totalWidth,\n        minY: 0,\n        maxY: this.parsedHeight\n      };\n      var padding = this.parsedPadding;\n      return {\n        minX: padding,\n        maxX: this.totalWidth - padding,\n        minY: padding,\n        maxY: this.parsedHeight - padding\n      };\n    },\n    hasLabels: function hasLabels() {\n      return Boolean(this.showLabels || this.labels.length > 0 || this.$scopedSlots.label);\n    },\n    parsedLabels: function parsedLabels() {\n      var labels = [];\n      var points = this._values;\n      var len = points.length;\n\n      for (var i = 0; labels.length < len; i++) {\n        var item = points[i];\n        var value = this.labels[i];\n\n        if (!value) {\n          value = _typeof(item) === 'object' ? item.value : item;\n        }\n\n        labels.push({\n          x: item.x,\n          value: String(value)\n        });\n      }\n\n      return labels;\n    },\n    normalizedValues: function normalizedValues() {\n      return this.value.map(function (item) {\n        return typeof item === 'number' ? item : item.value;\n      });\n    },\n    _values: function _values() {\n      return this.type === 'trend' ? genPoints(this.normalizedValues, this.boundary) : _genBars(this.normalizedValues, this.boundary);\n    },\n    textY: function textY() {\n      var y = this.parsedHeight;\n      if (this.type === 'trend') y -= 4;\n      return y;\n    },\n    _radius: function _radius() {\n      return this.smooth === true ? 8 : Number(this.smooth);\n    }\n  },\n  watch: {\n    value: {\n      immediate: true,\n      handler: function handler() {\n        var _this = this;\n\n        this.$nextTick(function () {\n          if (!_this.autoDraw || _this.type === 'bar') return;\n          var path = _this.$refs.path;\n          var length = path.getTotalLength();\n\n          if (!_this.fill) {\n            path.style.transition = 'none';\n            path.style.strokeDasharray = length + ' ' + length;\n            path.style.strokeDashoffset = Math.abs(length - (_this.lastLength || 0)).toString();\n            path.getBoundingClientRect();\n            path.style.transition = \"stroke-dashoffset \".concat(_this.autoDrawDuration, \"ms \").concat(_this.autoDrawEasing);\n            path.style.strokeDashoffset = '0';\n          } else {\n            path.style.transformOrigin = 'bottom center';\n            path.style.transition = 'none';\n            path.style.transform = \"scaleY(0)\";\n            path.getBoundingClientRect();\n            path.style.transition = \"transform \".concat(_this.autoDrawDuration, \"ms \").concat(_this.autoDrawEasing);\n            path.style.transform = \"scaleY(1)\";\n          }\n\n          _this.lastLength = length;\n        });\n      }\n    }\n  },\n  methods: {\n    genGradient: function genGradient() {\n      var _this2 = this;\n\n      var gradientDirection = this.gradientDirection;\n      var gradient = this.gradient.slice(); // Pushes empty string to force\n      // a fallback to currentColor\n\n      if (!gradient.length) gradient.push('');\n      var len = Math.max(gradient.length - 1, 1);\n      var stops = gradient.reverse().map(function (color, index) {\n        return _this2.$createElement('stop', {\n          attrs: {\n            offset: index / len,\n            'stop-color': color || _this2.color || 'currentColor'\n          }\n        });\n      });\n      return this.$createElement('defs', [this.$createElement('linearGradient', {\n        attrs: {\n          id: this._uid,\n          x1: +(gradientDirection === 'left'),\n          y1: +(gradientDirection === 'top'),\n          x2: +(gradientDirection === 'right'),\n          y2: +(gradientDirection === 'bottom')\n        }\n      }, stops)]);\n    },\n    genG: function genG(children) {\n      return this.$createElement('g', {\n        style: {\n          fontSize: '8',\n          textAnchor: 'middle',\n          dominantBaseline: 'mathematical',\n          fill: this.color || 'currentColor'\n        }\n      }, children);\n    },\n    genPath: function genPath() {\n      var points = genPoints(this.normalizedValues, this.boundary);\n      return this.$createElement('path', {\n        attrs: {\n          id: this._uid,\n          d: _genPath(points, this._radius, this.fill, this.parsedHeight),\n          fill: this.fill ? \"url(#\".concat(this._uid, \")\") : 'none',\n          stroke: this.fill ? 'none' : \"url(#\".concat(this._uid, \")\")\n        },\n        ref: 'path'\n      });\n    },\n    genLabels: function genLabels(offsetX) {\n      var _this3 = this;\n\n      var children = this.parsedLabels.map(function (item, i) {\n        return _this3.$createElement('text', {\n          attrs: {\n            x: item.x + offsetX + _this3._lineWidth / 2,\n            y: _this3.textY + _this3.parsedLabelSize * 0.75,\n            'font-size': Number(_this3.labelSize) || 7\n          }\n        }, [_this3.genLabel(item, i)]);\n      });\n      return this.genG(children);\n    },\n    genLabel: function genLabel(item, index) {\n      return this.$scopedSlots.label ? this.$scopedSlots.label({\n        index: index,\n        value: item.value\n      }) : item.value;\n    },\n    genBars: function genBars() {\n      if (!this.value || this.totalValues < 2) return undefined;\n\n      var bars = _genBars(this.normalizedValues, this.boundary);\n\n      var offsetX = (Math.abs(bars[0].x - bars[1].x) - this._lineWidth) / 2;\n      return this.$createElement('svg', {\n        attrs: {\n          display: 'block',\n          viewBox: \"0 0 \".concat(this.totalWidth, \" \").concat(this.totalHeight)\n        }\n      }, [this.genGradient(), this.genClipPath(bars, offsetX, this._lineWidth, 'sparkline-bar-' + this._uid), this.hasLabels ? this.genLabels(offsetX) : undefined, this.$createElement('g', {\n        attrs: {\n          'clip-path': \"url(#sparkline-bar-\".concat(this._uid, \"-clip)\"),\n          fill: \"url(#\".concat(this._uid, \")\")\n        }\n      }, [this.$createElement('rect', {\n        attrs: {\n          x: 0,\n          y: 0,\n          width: this.totalWidth,\n          height: this.height\n        }\n      })])]);\n    },\n    genClipPath: function genClipPath(bars, offsetX, lineWidth, id) {\n      var _this4 = this;\n\n      var rounding = typeof this.smooth === 'number' ? this.smooth : this.smooth ? 2 : 0;\n      return this.$createElement('clipPath', {\n        attrs: {\n          id: \"\".concat(id, \"-clip\")\n        }\n      }, bars.map(function (item) {\n        return _this4.$createElement('rect', {\n          attrs: {\n            x: item.x + offsetX,\n            y: item.y,\n            width: lineWidth,\n            height: item.height,\n            rx: rounding,\n            ry: rounding\n          }\n        }, [_this4.autoDraw ? _this4.$createElement('animate', {\n          attrs: {\n            attributeName: 'height',\n            from: 0,\n            to: item.height,\n            dur: \"\".concat(_this4.autoDrawDuration, \"ms\"),\n            fill: 'freeze'\n          }\n        }) : undefined]);\n      }));\n    },\n    genTrend: function genTrend() {\n      return this.$createElement('svg', this.setTextColor(this.color, {\n        attrs: _objectSpread({}, this.$attrs, {\n          display: 'block',\n          'stroke-width': this._lineWidth || 1,\n          viewBox: \"0 0 \".concat(this.width, \" \").concat(this.totalHeight)\n        })\n      }), [this.genGradient(), this.hasLabels && this.genLabels(-(this._lineWidth / 2)), this.genPath()]);\n    }\n  },\n  render: function render(h) {\n    if (this.totalValues < 2) return undefined;\n    return this.type === 'trend' ? this.genTrend() : this.genBars();\n  }\n});",null]}