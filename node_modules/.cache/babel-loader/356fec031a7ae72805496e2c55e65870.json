{"remainingRequest":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js??ref--13-0!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/crypto.js","dependencies":[{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/crypto.js","mtime":1585119550000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.typed.uint32-array\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport CryptoJS from \"crypto-js\";\nimport Base58 from \"base-58\";\nimport blake from \"blake2b\";\nimport Sha3 from \"js-sha3\";\nimport Axlsign from \"./axlsign\";\nimport converters from \"./converters\";\nimport secure_random from \"./secure-random\";\nimport Concat from \"./concat\";\nimport * as constants from \"../constants\";\n\nfunction sha256(input) {\n  var bytes;\n\n  if (typeof input === \"string\") {\n    bytes = converters.stringToByteArray(input);\n  } else {\n    bytes = input;\n  }\n\n  var wordArray = converters.byteArrayToWordArrayEx(Uint8Array.from(bytes));\n  var resultWordArray = CryptoJS.SHA256(wordArray);\n  return converters.wordArrayToByteArrayEx(resultWordArray);\n}\n\nfunction blake2b(input) {\n  var output = new Uint8Array(32);\n  blake(output.length).update(input).digest(output);\n  return output;\n}\n\nfunction keccak(input) {\n  return Sha3.keccak256.array(input);\n}\n\nfunction hashChain(input) {\n  return keccak(blake2b(input));\n}\n\nfunction buildSeedHash(seed, nonce) {\n  var seedNonceStr = nonce.toString() + seed;\n  var seedBytesWithNonce = Uint8Array.from(converters.stringToByteArray(seedNonceStr));\n  var seedHash = hashChain(seedBytesWithNonce);\n  return sha256(seedHash);\n}\n\nfunction strengthenPassword(password, rounds) {\n  if (rounds === void 0) {\n    rounds = 5000;\n  }\n\n  while (rounds--) {\n    password = converters.byteArrayToHexString(sha256(password));\n  }\n\n  return password;\n}\n\nvar Crypto = {\n  sha256ForCheckSum: function sha256ForCheckSum(input) {\n    var checkSum = converters.byteArrayToHexString(sha256(input));\n    return checkSum.slice(0, 8);\n  },\n  buildTransactionSignature: function buildTransactionSignature(dataBytes, privateKey) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n\n    if (!privateKey || typeof privateKey !== \"string\") {\n      throw new Error(\"Missing or invalid private key\");\n    }\n\n    var privateKeyBytes = Base58.decode(privateKey);\n\n    if (privateKeyBytes.length !== constants.PRIVATE_KEY_BYTE_LENGTH) {\n      throw new Error(\"Invalid private key\");\n    }\n\n    var signature = Axlsign.sign(privateKeyBytes, dataBytes, secure_random.randomUint8Array(64));\n    return Base58.encode(signature);\n  },\n  isValidTransactionSignature: function isValidTransactionSignature(dataBytes, signature, publicKey) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n\n    if (!signature || typeof signature !== \"string\") {\n      throw new Error(\"Missing or invalid signature\");\n    }\n\n    if (!publicKey || typeof publicKey !== \"string\") {\n      throw new Error(\"Missing or invalid public key\");\n    }\n\n    var signatureBytes = Base58.decode(signature);\n    var publicKeyBytes = Base58.decode(publicKey);\n\n    if (publicKeyBytes.length !== constants.PUBLIC_KEY_BYTE_LENGTH) {\n      throw new Error(\"Invalid public key\");\n    }\n\n    return Axlsign.verify(publicKeyBytes, dataBytes, signatureBytes);\n  },\n  buildTransactionId: function buildTransactionId(dataBytes) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n\n    var hash = blake2b(dataBytes);\n    return Base58.encode(hash);\n  },\n  buildKeyPair: function buildKeyPair(seed, nonce) {\n    if (typeof seed !== \"string\") {\n      throw new Error(\"Invalid seed phrase\");\n    }\n\n    var seedHash = buildSeedHash(seed, nonce);\n    var keypair = Axlsign.generateKeyPair(seedHash);\n    return {\n      privateKey: keypair.private,\n      publicKey: keypair.public\n    };\n  },\n  buildKeyPairFromPrivateKey: function buildKeyPairFromPrivateKey(privateKey) {\n    if (!privateKey) {\n      throw new Error(\"Invalid private key\");\n    }\n\n    var privateKeyBytes = privateKey;\n\n    if (!(privateKey instanceof Uint8Array)) {\n      privateKeyBytes = Base58.decode(privateKey);\n    }\n\n    var publicKeyBytes = Axlsign.derivePublicKey(privateKeyBytes);\n    return {\n      privateKey: privateKeyBytes,\n      publicKey: publicKeyBytes\n    };\n  },\n  isValidAddress: function isValidAddress(address, networkByte) {\n    if (!address || typeof address !== \"string\") {\n      return false;\n    }\n\n    var addressBytes = Base58.decode(address);\n\n    if (addressBytes[0] !== constants.ADDRESS_VERSION || addressBytes[1] !== networkByte) {\n      return false;\n    }\n\n    var key = addressBytes.slice(0, 22);\n    var check = addressBytes.slice(22, 26);\n    var keyHash = hashChain(key).slice(0, 4);\n\n    for (var i = 0; i < 4; i++) {\n      if (check[i] !== keyHash[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  isValidPublicKey: function isValidPublicKey(publicKey, address, networkByte) {\n    try {\n      return Crypto.buildRawAddress(Base58.decode(publicKey), networkByte) === address;\n    } catch (_unused) {\n      return false;\n    }\n  },\n  buildRawAddress: function buildRawAddress(publicKeyBytes, networkByte) {\n    if (!publicKeyBytes || publicKeyBytes.length !== constants.PUBLIC_KEY_BYTE_LENGTH || !(publicKeyBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid public key\");\n    }\n\n    var prefix = Uint8Array.from([constants.ADDRESS_VERSION, networkByte]);\n    var publicKeyHashPart = Uint8Array.from(hashChain(publicKeyBytes).slice(0, 20));\n    var rawAddress = Concat.concatUint8Arrays(prefix, publicKeyHashPart);\n    var addressHash = Uint8Array.from(hashChain(rawAddress).slice(0, 4));\n    return Base58.encode(Concat.concatUint8Arrays(rawAddress, addressHash));\n  },\n  encryptSeed: function encryptSeed(seed, password, encryptionRounds) {\n    if (typeof seed !== \"string\") {\n      throw new Error(\"Seed is required\");\n    }\n\n    if (!password || typeof password !== \"string\") {\n      throw new Error(\"Password is required\");\n    }\n\n    password = strengthenPassword(password, encryptionRounds);\n    return CryptoJS.AES.encrypt(seed, password).toString();\n  },\n  decryptSeed: function decryptSeed(encryptedSeed, password, encryptionRounds) {\n    if (!encryptedSeed || typeof encryptedSeed !== \"string\") {\n      throw new Error(\"Encrypted seed is required\");\n    }\n\n    if (!password || typeof password !== \"string\") {\n      throw new Error(\"Password is required\");\n    }\n\n    password = strengthenPassword(password, encryptionRounds);\n    var hexSeed = CryptoJS.AES.decrypt(encryptedSeed, password);\n    return converters.hexStringToString(hexSeed.toString());\n  },\n  generateRandomUint32Array: function generateRandomUint32Array(length) {\n    if (!length || length < 0) {\n      throw new Error(\"Missing or invalid array length\");\n    }\n\n    var a = secure_random.randomUint8Array(length);\n    var b = secure_random.randomUint8Array(length);\n    var result = new Uint32Array(length);\n\n    for (var i = 0; i < length; i++) {\n      var hash = converters.byteArrayToHexString(sha256(\"\" + a[i] + b[i]));\n      var randomValue = parseInt(hash.slice(0, 13), 16);\n      result.set([randomValue], i);\n    }\n\n    return result;\n  },\n  hash: function hash(input) {\n    return hashChain(input);\n  }\n};\nexport default Crypto;",{"version":3,"sources":["/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/crypto.js"],"names":["CryptoJS","Base58","blake","Sha3","Axlsign","converters","secure_random","Concat","constants","sha256","input","bytes","stringToByteArray","wordArray","byteArrayToWordArrayEx","Uint8Array","from","resultWordArray","SHA256","wordArrayToByteArrayEx","blake2b","output","length","update","digest","keccak","keccak256","array","hashChain","buildSeedHash","seed","nonce","seedNonceStr","toString","seedBytesWithNonce","seedHash","strengthenPassword","password","rounds","byteArrayToHexString","Crypto","sha256ForCheckSum","checkSum","slice","buildTransactionSignature","dataBytes","privateKey","Error","privateKeyBytes","decode","PRIVATE_KEY_BYTE_LENGTH","signature","sign","randomUint8Array","encode","isValidTransactionSignature","publicKey","signatureBytes","publicKeyBytes","PUBLIC_KEY_BYTE_LENGTH","verify","buildTransactionId","hash","buildKeyPair","keypair","generateKeyPair","private","public","buildKeyPairFromPrivateKey","derivePublicKey","isValidAddress","address","networkByte","addressBytes","ADDRESS_VERSION","key","check","keyHash","i","isValidPublicKey","buildRawAddress","prefix","publicKeyHashPart","rawAddress","concatUint8Arrays","addressHash","encryptSeed","encryptionRounds","AES","encrypt","decryptSeed","encryptedSeed","hexSeed","decrypt","hexStringToString","generateRandomUint32Array","a","b","result","Uint32Array","randomValue","parseInt","set"],"mappings":"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","sourcesContent":["import CryptoJS from \"crypto-js\";\nimport Base58 from \"base-58\";\nimport blake from \"blake2b\";\nimport Sha3 from \"js-sha3\";\nimport Axlsign from \"./axlsign\";\nimport converters from \"./converters\";\nimport secure_random from \"./secure-random\";\nimport Concat from \"./concat\";\nimport * as constants from \"../constants\";\n\nfunction sha256(input) {\n  let bytes;\n  if (typeof input === \"string\") {\n    bytes = converters.stringToByteArray(input);\n  } else {\n    bytes = input;\n  }\n  let wordArray = converters.byteArrayToWordArrayEx(Uint8Array.from(bytes));\n  let resultWordArray = CryptoJS.SHA256(wordArray);\n  return converters.wordArrayToByteArrayEx(resultWordArray);\n}\n\nfunction blake2b(input) {\n  let output = new Uint8Array(32);\n  blake(output.length)\n    .update(input)\n    .digest(output);\n  return output;\n}\n\nfunction keccak(input) {\n  return Sha3.keccak256.array(input);\n}\n\nfunction hashChain(input) {\n  return keccak(blake2b(input));\n}\n\nfunction buildSeedHash(seed, nonce) {\n  let seedNonceStr = nonce.toString() + seed;\n  let seedBytesWithNonce = Uint8Array.from(\n    converters.stringToByteArray(seedNonceStr)\n  );\n  let seedHash = hashChain(seedBytesWithNonce);\n  return sha256(seedHash);\n}\n\nfunction strengthenPassword(password, rounds) {\n  if (rounds === void 0) {\n    rounds = 5000;\n  }\n  while (rounds--) password = converters.byteArrayToHexString(sha256(password));\n  return password;\n}\nconst Crypto = {\n  sha256ForCheckSum(input) {\n    const checkSum = converters.byteArrayToHexString(sha256(input));\n    return checkSum.slice(0, 8);\n  },\n  buildTransactionSignature(dataBytes, privateKey) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n    if (!privateKey || typeof privateKey !== \"string\") {\n      throw new Error(\"Missing or invalid private key\");\n    }\n    const privateKeyBytes = Base58.decode(privateKey);\n    if (privateKeyBytes.length !== constants.PRIVATE_KEY_BYTE_LENGTH) {\n      throw new Error(\"Invalid private key\");\n    }\n    const signature = Axlsign.sign(\n      privateKeyBytes,\n      dataBytes,\n      secure_random.randomUint8Array(64)\n    );\n    return Base58.encode(signature);\n  },\n  isValidTransactionSignature(dataBytes, signature, publicKey) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n    if (!signature || typeof signature !== \"string\") {\n      throw new Error(\"Missing or invalid signature\");\n    }\n    if (!publicKey || typeof publicKey !== \"string\") {\n      throw new Error(\"Missing or invalid public key\");\n    }\n    let signatureBytes = Base58.decode(signature);\n    let publicKeyBytes = Base58.decode(publicKey);\n    if (publicKeyBytes.length !== constants.PUBLIC_KEY_BYTE_LENGTH) {\n      throw new Error(\"Invalid public key\");\n    }\n    return Axlsign.verify(publicKeyBytes, dataBytes, signatureBytes);\n  },\n  buildTransactionId(dataBytes) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n    let hash = blake2b(dataBytes);\n    return Base58.encode(hash);\n  },\n  buildKeyPair(seed, nonce) {\n    if (typeof seed !== \"string\") {\n      throw new Error(\"Invalid seed phrase\");\n    }\n    let seedHash = buildSeedHash(seed, nonce);\n    const keypair = Axlsign.generateKeyPair(seedHash);\n    return {\n      privateKey: keypair.private,\n      publicKey: keypair.public\n    };\n  },\n  buildKeyPairFromPrivateKey(privateKey) {\n    if (!privateKey) {\n      throw new Error(\"Invalid private key\");\n    }\n    let privateKeyBytes = privateKey;\n    if (!(privateKey instanceof Uint8Array)) {\n      privateKeyBytes = Base58.decode(privateKey);\n    }\n    const publicKeyBytes = Axlsign.derivePublicKey(privateKeyBytes);\n    return {\n      privateKey: privateKeyBytes,\n      publicKey: publicKeyBytes\n    };\n  },\n  isValidAddress(address, networkByte) {\n    if (!address || typeof address !== \"string\") {\n      return false;\n    }\n    let addressBytes = Base58.decode(address);\n    if (\n      addressBytes[0] !== constants.ADDRESS_VERSION ||\n      addressBytes[1] !== networkByte\n    ) {\n      return false;\n    }\n    let key = addressBytes.slice(0, 22);\n    let check = addressBytes.slice(22, 26);\n    let keyHash = hashChain(key).slice(0, 4);\n    for (let i = 0; i < 4; i++) {\n      if (check[i] !== keyHash[i]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  isValidPublicKey(publicKey, address, networkByte) {\n    try {\n      return (\n        Crypto.buildRawAddress(Base58.decode(publicKey), networkByte) ===\n        address\n      );\n    } catch {\n      return false;\n    }\n  },\n  buildRawAddress(publicKeyBytes, networkByte) {\n    if (\n      !publicKeyBytes ||\n      publicKeyBytes.length !== constants.PUBLIC_KEY_BYTE_LENGTH ||\n      !(publicKeyBytes instanceof Uint8Array)\n    ) {\n      throw new Error(\"Missing or invalid public key\");\n    }\n    let prefix = Uint8Array.from([constants.ADDRESS_VERSION, networkByte]);\n    let publicKeyHashPart = Uint8Array.from(\n      hashChain(publicKeyBytes).slice(0, 20)\n    );\n    let rawAddress = Concat.concatUint8Arrays(prefix, publicKeyHashPart);\n    let addressHash = Uint8Array.from(hashChain(rawAddress).slice(0, 4));\n    return Base58.encode(Concat.concatUint8Arrays(rawAddress, addressHash));\n  },\n  encryptSeed(seed, password, encryptionRounds) {\n    if (typeof seed !== \"string\") {\n      throw new Error(\"Seed is required\");\n    }\n    if (!password || typeof password !== \"string\") {\n      throw new Error(\"Password is required\");\n    }\n    password = strengthenPassword(password, encryptionRounds);\n    return CryptoJS.AES.encrypt(seed, password).toString();\n  },\n  decryptSeed(encryptedSeed, password, encryptionRounds) {\n    if (!encryptedSeed || typeof encryptedSeed !== \"string\") {\n      throw new Error(\"Encrypted seed is required\");\n    }\n    if (!password || typeof password !== \"string\") {\n      throw new Error(\"Password is required\");\n    }\n    password = strengthenPassword(password, encryptionRounds);\n    let hexSeed = CryptoJS.AES.decrypt(encryptedSeed, password);\n    return converters.hexStringToString(hexSeed.toString());\n  },\n  generateRandomUint32Array(length) {\n    if (!length || length < 0) {\n      throw new Error(\"Missing or invalid array length\");\n    }\n    let a = secure_random.randomUint8Array(length);\n    let b = secure_random.randomUint8Array(length);\n    let result = new Uint32Array(length);\n    for (let i = 0; i < length; i++) {\n      let hash = converters.byteArrayToHexString(sha256(\"\" + a[i] + b[i]));\n      let randomValue = parseInt(hash.slice(0, 13), 16);\n      result.set([randomValue], i);\n    }\n    return result;\n  },\n  hash(input) {\n    return hashChain(input);\n  }\n};\n\nexport default Crypto;\n"]}]}