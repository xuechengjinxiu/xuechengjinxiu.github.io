{"remainingRequest":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js??ref--13-0!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/crypto.js","dependencies":[{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/crypto.js","mtime":1585119550000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.typed.uint32-array\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport CryptoJS from \"crypto-js\";\nimport Base58 from \"base-58\";\nimport blake from \"blake2b\";\nimport Sha3 from \"js-sha3\";\nimport Axlsign from \"./axlsign\";\nimport converters from \"./converters\";\nimport secure_random from \"./secure-random\";\nimport Concat from \"./concat\";\nimport * as constants from \"../constants\";\n\nfunction sha256(input) {\n  var bytes;\n\n  if (typeof input === \"string\") {\n    bytes = converters.stringToByteArray(input);\n  } else {\n    bytes = input;\n  }\n\n  var wordArray = converters.byteArrayToWordArrayEx(Uint8Array.from(bytes));\n  var resultWordArray = CryptoJS.SHA256(wordArray);\n  return converters.wordArrayToByteArrayEx(resultWordArray);\n}\n\nfunction blake2b(input) {\n  var output = new Uint8Array(32);\n  blake(output.length).update(input).digest(output);\n  return output;\n}\n\nfunction keccak(input) {\n  return Sha3.keccak256.array(input);\n}\n\nfunction hashChain(input) {\n  return keccak(blake2b(input));\n}\n\nfunction buildSeedHash(seed, nonce) {\n  var seedNonceStr = nonce.toString() + seed;\n  var seedBytesWithNonce = Uint8Array.from(converters.stringToByteArray(seedNonceStr));\n  var seedHash = hashChain(seedBytesWithNonce);\n  return sha256(seedHash);\n}\n\nfunction strengthenPassword(password, rounds) {\n  if (rounds === void 0) {\n    rounds = 5000;\n  }\n\n  while (rounds--) {\n    password = converters.byteArrayToHexString(sha256(password));\n  }\n\n  return password;\n}\n\nvar Crypto = {\n  sha256ForCheckSum: function sha256ForCheckSum(input) {\n    var checkSum = converters.byteArrayToHexString(sha256(input));\n    return checkSum.slice(0, 8);\n  },\n  buildTransactionSignature: function buildTransactionSignature(dataBytes, privateKey) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n\n    if (!privateKey || typeof privateKey !== \"string\") {\n      throw new Error(\"Missing or invalid private key\");\n    }\n\n    var privateKeyBytes = Base58.decode(privateKey);\n\n    if (privateKeyBytes.length !== constants.PRIVATE_KEY_BYTE_LENGTH) {\n      throw new Error(\"Invalid private key\");\n    }\n\n    var signature = Axlsign.sign(privateKeyBytes, dataBytes, secure_random.randomUint8Array(64));\n    return Base58.encode(signature);\n  },\n  isValidTransactionSignature: function isValidTransactionSignature(dataBytes, signature, publicKey) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n\n    if (!signature || typeof signature !== \"string\") {\n      throw new Error(\"Missing or invalid signature\");\n    }\n\n    if (!publicKey || typeof publicKey !== \"string\") {\n      throw new Error(\"Missing or invalid public key\");\n    }\n\n    var signatureBytes = Base58.decode(signature);\n    var publicKeyBytes = Base58.decode(publicKey);\n\n    if (publicKeyBytes.length !== constants.PUBLIC_KEY_BYTE_LENGTH) {\n      throw new Error(\"Invalid public key\");\n    }\n\n    return Axlsign.verify(publicKeyBytes, dataBytes, signatureBytes);\n  },\n  buildTransactionId: function buildTransactionId(dataBytes) {\n    if (!dataBytes || !(dataBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid data\");\n    }\n\n    var hash = blake2b(dataBytes);\n    return Base58.encode(hash);\n  },\n  buildKeyPair: function buildKeyPair(seed, nonce) {\n    if (typeof seed !== \"string\") {\n      throw new Error(\"Invalid seed phrase\");\n    }\n\n    var seedHash = buildSeedHash(seed, nonce);\n    var keypair = Axlsign.generateKeyPair(seedHash);\n    return {\n      privateKey: keypair.private,\n      publicKey: keypair.public\n    };\n  },\n  buildKeyPairFromPrivateKey: function buildKeyPairFromPrivateKey(privateKey) {\n    if (!privateKey) {\n      throw new Error(\"Invalid private key\");\n    }\n\n    var privateKeyBytes = privateKey;\n\n    if (!(privateKey instanceof Uint8Array)) {\n      privateKeyBytes = Base58.decode(privateKey);\n    }\n\n    var publicKeyBytes = Axlsign.derivePublicKey(privateKeyBytes);\n    return {\n      privateKey: privateKeyBytes,\n      publicKey: publicKeyBytes\n    };\n  },\n  isValidAddress: function isValidAddress(address, networkByte) {\n    if (!address || typeof address !== \"string\") {\n      return false;\n    }\n\n    var addressBytes = Base58.decode(address);\n\n    if (addressBytes[0] !== constants.ADDRESS_VERSION || addressBytes[1] !== networkByte) {\n      return false;\n    }\n\n    var key = addressBytes.slice(0, 22);\n    var check = addressBytes.slice(22, 26);\n    var keyHash = hashChain(key).slice(0, 4);\n\n    for (var i = 0; i < 4; i++) {\n      if (check[i] !== keyHash[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  isValidPublicKey: function isValidPublicKey(publicKey, address, networkByte) {\n    try {\n      return Crypto.buildRawAddress(Base58.decode(publicKey), networkByte) === address;\n    } catch (_unused) {\n      return false;\n    }\n  },\n  buildRawAddress: function buildRawAddress(publicKeyBytes, networkByte) {\n    if (!publicKeyBytes || publicKeyBytes.length !== constants.PUBLIC_KEY_BYTE_LENGTH || !(publicKeyBytes instanceof Uint8Array)) {\n      throw new Error(\"Missing or invalid public key\");\n    }\n\n    var prefix = Uint8Array.from([constants.ADDRESS_VERSION, networkByte]);\n    var publicKeyHashPart = Uint8Array.from(hashChain(publicKeyBytes).slice(0, 20));\n    var rawAddress = Concat.concatUint8Arrays(prefix, publicKeyHashPart);\n    var addressHash = Uint8Array.from(hashChain(rawAddress).slice(0, 4));\n    return Base58.encode(Concat.concatUint8Arrays(rawAddress, addressHash));\n  },\n  encryptSeed: function encryptSeed(seed, password, encryptionRounds) {\n    if (typeof seed !== \"string\") {\n      throw new Error(\"Seed is required\");\n    }\n\n    if (!password || typeof password !== \"string\") {\n      throw new Error(\"Password is required\");\n    }\n\n    password = strengthenPassword(password, encryptionRounds);\n    return CryptoJS.AES.encrypt(seed, password).toString();\n  },\n  decryptSeed: function decryptSeed(encryptedSeed, password, encryptionRounds) {\n    if (!encryptedSeed || typeof encryptedSeed !== \"string\") {\n      throw new Error(\"Encrypted seed is required\");\n    }\n\n    if (!password || typeof password !== \"string\") {\n      throw new Error(\"Password is required\");\n    }\n\n    password = strengthenPassword(password, encryptionRounds);\n    var hexSeed = CryptoJS.AES.decrypt(encryptedSeed, password);\n    return converters.hexStringToString(hexSeed.toString());\n  },\n  generateRandomUint32Array: function generateRandomUint32Array(length) {\n    if (!length || length < 0) {\n      throw new Error(\"Missing or invalid array length\");\n    }\n\n    var a = secure_random.randomUint8Array(length);\n    var b = secure_random.randomUint8Array(length);\n    var result = new Uint32Array(length);\n\n    for (var i = 0; i < length; i++) {\n      var hash = converters.byteArrayToHexString(sha256(\"\" + a[i] + b[i]));\n      var randomValue = parseInt(hash.slice(0, 13), 16);\n      result.set([randomValue], i);\n    }\n\n    return result;\n  },\n  hash: function hash(input) {\n    return hashChain(input);\n  }\n};\nexport default Crypto;",null]}