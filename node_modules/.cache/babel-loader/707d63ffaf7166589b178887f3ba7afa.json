{"remainingRequest":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/vuetify/lib/components/VCombobox/VCombobox.js","dependencies":[{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/vuetify/lib/components/VCombobox/VCombobox.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport _defineProperty from \"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.string.ends-with\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.regexp.to-string\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Styles\nimport \"../../../src/components/VAutocomplete/VAutocomplete.sass\"; // Extensions\n\nimport VSelect from \"../VSelect/VSelect\";\nimport VAutocomplete from \"../VAutocomplete/VAutocomplete\"; // Utils\n\nimport { keyCodes } from \"../../util/helpers\";\n/* @vue/component */\n\nexport default VAutocomplete.extend({\n  name: 'v-combobox',\n  props: {\n    delimiters: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    returnObject: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data: function data() {\n    return {\n      editingIndex: -1\n    };\n  },\n  computed: {\n    counterValue: function counterValue() {\n      return this.multiple ? this.selectedItems.length : (this.internalSearch || '').toString().length;\n    },\n    hasSlot: function hasSlot() {\n      return VSelect.options.computed.hasSlot.call(this) || this.multiple;\n    },\n    isAnyValueAllowed: function isAnyValueAllowed() {\n      return true;\n    },\n    menuCanShow: function menuCanShow() {\n      if (!this.isFocused) return false;\n      return this.hasDisplayedItems || !!this.$slots['no-data'] && !this.hideNoData;\n    }\n  },\n  methods: {\n    onInternalSearchChanged: function onInternalSearchChanged(val) {\n      if (val && this.multiple && this.delimiters.length) {\n        var delimiter = this.delimiters.find(function (d) {\n          return val.endsWith(d);\n        });\n\n        if (delimiter != null) {\n          this.internalSearch = val.slice(0, val.length - delimiter.length);\n          this.updateTags();\n        }\n      }\n\n      this.updateMenuDimensions();\n    },\n    genChipSelection: function genChipSelection(item, index) {\n      var _this = this;\n\n      var chip = VSelect.options.methods.genChipSelection.call(this, item, index); // Allow user to update an existing value\n\n      if (this.multiple) {\n        chip.componentOptions.listeners = _objectSpread({}, chip.componentOptions.listeners, {\n          dblclick: function dblclick() {\n            _this.editingIndex = index;\n            _this.internalSearch = _this.getText(item);\n            _this.selectedIndex = -1;\n          }\n        });\n      }\n\n      return chip;\n    },\n    onChipInput: function onChipInput(item) {\n      VSelect.options.methods.onChipInput.call(this, item);\n      this.editingIndex = -1;\n    },\n    // Requires a manual definition\n    // to overwrite removal in v-autocomplete\n    onEnterDown: function onEnterDown(e) {\n      var _this2 = this;\n\n      e.preventDefault();\n      this.$nextTick(function () {\n        // If has menu index, let v-select-list handle\n        if (_this2.getMenuIndex() > -1) return;\n\n        _this2.updateSelf();\n      });\n    },\n    onFilteredItemsChanged: function onFilteredItemsChanged(val, oldVal) {\n      if (!this.autoSelectFirst) return;\n      VAutocomplete.options.methods.onFilteredItemsChanged.call(this, val, oldVal);\n    },\n    onKeyDown: function onKeyDown(e) {\n      var keyCode = e.keyCode;\n      VSelect.options.methods.onKeyDown.call(this, e); // If user is at selection index of 0\n      // create a new tag\n\n      if (this.multiple && keyCode === keyCodes.left && this.$refs.input.selectionStart === 0) {\n        this.updateSelf();\n      } else if (keyCode === keyCodes.enter) {\n        this.onEnterDown(e);\n      } // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n\n\n      this.changeSelectedIndex(keyCode);\n    },\n    onTabDown: function onTabDown(e) {\n      // When adding tags, if searching and\n      // there is not a filtered options,\n      // add the value to the tags list\n      if (this.multiple && this.internalSearch && this.getMenuIndex() === -1) {\n        e.preventDefault();\n        e.stopPropagation();\n        return this.updateTags();\n      }\n\n      VAutocomplete.options.methods.onTabDown.call(this, e);\n    },\n    selectItem: function selectItem(item) {\n      // Currently only supports items:<string[]>\n      if (this.editingIndex > -1) {\n        this.updateEditing();\n      } else {\n        VAutocomplete.options.methods.selectItem.call(this, item);\n      }\n    },\n    setSelectedItems: function setSelectedItems() {\n      if (this.internalValue == null || this.internalValue === '') {\n        this.selectedItems = [];\n      } else {\n        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];\n      }\n    },\n    setValue: function setValue(value) {\n      VSelect.options.methods.setValue.call(this, value != null ? value : this.internalSearch);\n    },\n    updateEditing: function updateEditing() {\n      var value = this.internalValue.slice();\n      value[this.editingIndex] = this.internalSearch;\n      this.setValue(value);\n      this.editingIndex = -1;\n    },\n    updateCombobox: function updateCombobox() {\n      var isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips; // If search is not dirty and is\n      // using slot, do nothing\n\n      if (isUsingSlot && !this.searchIsDirty) return; // The internal search is not matching\n      // the internal value, update the input\n\n      if (this.internalSearch !== this.getText(this.internalValue)) this.setValue(); // Reset search if using slot\n      // to avoid a double input\n\n      if (isUsingSlot) this.internalSearch = undefined;\n    },\n    updateSelf: function updateSelf() {\n      this.multiple ? this.updateTags() : this.updateCombobox();\n    },\n    updateTags: function updateTags() {\n      var menuIndex = this.getMenuIndex(); // If the user is not searching\n      // and no menu item is selected\n      // do nothing\n\n      if (menuIndex < 0 && !this.searchIsDirty) return;\n\n      if (this.editingIndex > -1) {\n        return this.updateEditing();\n      }\n\n      var index = this.selectedItems.indexOf(this.internalSearch); // If it already exists, do nothing\n      // this might need to change to bring\n      // the duplicated item to the last entered\n\n      if (index > -1) {\n        var internalValue = this.internalValue.slice();\n        internalValue.splice(index, 1);\n        this.setValue(internalValue);\n      } // If menu index is greater than 1\n      // the selection is handled elsewhere\n      // TODO: find out where\n\n\n      if (menuIndex > -1) return this.internalSearch = null;\n      this.selectItem(this.internalSearch);\n      this.internalSearch = null;\n    }\n  }\n});",{"version":3,"sources":["/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/vuetify/lib/components/VCombobox/VCombobox.js"],"names":["VSelect","VAutocomplete","keyCodes","extend","name","props","delimiters","type","Array","default","returnObject","Boolean","data","editingIndex","computed","counterValue","multiple","selectedItems","length","internalSearch","toString","hasSlot","options","call","isAnyValueAllowed","menuCanShow","isFocused","hasDisplayedItems","$slots","hideNoData","methods","onInternalSearchChanged","val","delimiter","find","d","endsWith","slice","updateTags","updateMenuDimensions","genChipSelection","item","index","chip","componentOptions","listeners","dblclick","getText","selectedIndex","onChipInput","onEnterDown","e","preventDefault","$nextTick","getMenuIndex","updateSelf","onFilteredItemsChanged","oldVal","autoSelectFirst","onKeyDown","keyCode","left","$refs","input","selectionStart","enter","changeSelectedIndex","onTabDown","stopPropagation","selectItem","updateEditing","setSelectedItems","internalValue","setValue","value","updateCombobox","isUsingSlot","$scopedSlots","selection","hasChips","searchIsDirty","undefined","menuIndex","indexOf","splice"],"mappings":"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","sourcesContent":["// Styles\nimport \"../../../src/components/VAutocomplete/VAutocomplete.sass\"; // Extensions\n\nimport VSelect from '../VSelect/VSelect';\nimport VAutocomplete from '../VAutocomplete/VAutocomplete'; // Utils\n\nimport { keyCodes } from '../../util/helpers';\n/* @vue/component */\n\nexport default VAutocomplete.extend({\n  name: 'v-combobox',\n  props: {\n    delimiters: {\n      type: Array,\n      default: () => []\n    },\n    returnObject: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data: () => ({\n    editingIndex: -1\n  }),\n  computed: {\n    counterValue() {\n      return this.multiple ? this.selectedItems.length : (this.internalSearch || '').toString().length;\n    },\n\n    hasSlot() {\n      return VSelect.options.computed.hasSlot.call(this) || this.multiple;\n    },\n\n    isAnyValueAllowed() {\n      return true;\n    },\n\n    menuCanShow() {\n      if (!this.isFocused) return false;\n      return this.hasDisplayedItems || !!this.$slots['no-data'] && !this.hideNoData;\n    }\n\n  },\n  methods: {\n    onInternalSearchChanged(val) {\n      if (val && this.multiple && this.delimiters.length) {\n        const delimiter = this.delimiters.find(d => val.endsWith(d));\n\n        if (delimiter != null) {\n          this.internalSearch = val.slice(0, val.length - delimiter.length);\n          this.updateTags();\n        }\n      }\n\n      this.updateMenuDimensions();\n    },\n\n    genChipSelection(item, index) {\n      const chip = VSelect.options.methods.genChipSelection.call(this, item, index); // Allow user to update an existing value\n\n      if (this.multiple) {\n        chip.componentOptions.listeners = { ...chip.componentOptions.listeners,\n          dblclick: () => {\n            this.editingIndex = index;\n            this.internalSearch = this.getText(item);\n            this.selectedIndex = -1;\n          }\n        };\n      }\n\n      return chip;\n    },\n\n    onChipInput(item) {\n      VSelect.options.methods.onChipInput.call(this, item);\n      this.editingIndex = -1;\n    },\n\n    // Requires a manual definition\n    // to overwrite removal in v-autocomplete\n    onEnterDown(e) {\n      e.preventDefault();\n      this.$nextTick(() => {\n        // If has menu index, let v-select-list handle\n        if (this.getMenuIndex() > -1) return;\n        this.updateSelf();\n      });\n    },\n\n    onFilteredItemsChanged(val, oldVal) {\n      if (!this.autoSelectFirst) return;\n      VAutocomplete.options.methods.onFilteredItemsChanged.call(this, val, oldVal);\n    },\n\n    onKeyDown(e) {\n      const keyCode = e.keyCode;\n      VSelect.options.methods.onKeyDown.call(this, e); // If user is at selection index of 0\n      // create a new tag\n\n      if (this.multiple && keyCode === keyCodes.left && this.$refs.input.selectionStart === 0) {\n        this.updateSelf();\n      } else if (keyCode === keyCodes.enter) {\n        this.onEnterDown(e);\n      } // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n\n\n      this.changeSelectedIndex(keyCode);\n    },\n\n    onTabDown(e) {\n      // When adding tags, if searching and\n      // there is not a filtered options,\n      // add the value to the tags list\n      if (this.multiple && this.internalSearch && this.getMenuIndex() === -1) {\n        e.preventDefault();\n        e.stopPropagation();\n        return this.updateTags();\n      }\n\n      VAutocomplete.options.methods.onTabDown.call(this, e);\n    },\n\n    selectItem(item) {\n      // Currently only supports items:<string[]>\n      if (this.editingIndex > -1) {\n        this.updateEditing();\n      } else {\n        VAutocomplete.options.methods.selectItem.call(this, item);\n      }\n    },\n\n    setSelectedItems() {\n      if (this.internalValue == null || this.internalValue === '') {\n        this.selectedItems = [];\n      } else {\n        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];\n      }\n    },\n\n    setValue(value) {\n      VSelect.options.methods.setValue.call(this, value != null ? value : this.internalSearch);\n    },\n\n    updateEditing() {\n      const value = this.internalValue.slice();\n      value[this.editingIndex] = this.internalSearch;\n      this.setValue(value);\n      this.editingIndex = -1;\n    },\n\n    updateCombobox() {\n      const isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips; // If search is not dirty and is\n      // using slot, do nothing\n\n      if (isUsingSlot && !this.searchIsDirty) return; // The internal search is not matching\n      // the internal value, update the input\n\n      if (this.internalSearch !== this.getText(this.internalValue)) this.setValue(); // Reset search if using slot\n      // to avoid a double input\n\n      if (isUsingSlot) this.internalSearch = undefined;\n    },\n\n    updateSelf() {\n      this.multiple ? this.updateTags() : this.updateCombobox();\n    },\n\n    updateTags() {\n      const menuIndex = this.getMenuIndex(); // If the user is not searching\n      // and no menu item is selected\n      // do nothing\n\n      if (menuIndex < 0 && !this.searchIsDirty) return;\n\n      if (this.editingIndex > -1) {\n        return this.updateEditing();\n      }\n\n      const index = this.selectedItems.indexOf(this.internalSearch); // If it already exists, do nothing\n      // this might need to change to bring\n      // the duplicated item to the last entered\n\n      if (index > -1) {\n        const internalValue = this.internalValue.slice();\n        internalValue.splice(index, 1);\n        this.setValue(internalValue);\n      } // If menu index is greater than 1\n      // the selection is handled elsewhere\n      // TODO: find out where\n\n\n      if (menuIndex > -1) return this.internalSearch = null;\n      this.selectItem(this.internalSearch);\n      this.internalSearch = null;\n    }\n\n  }\n});\n//# sourceMappingURL=VCombobox.js.map"]}]}