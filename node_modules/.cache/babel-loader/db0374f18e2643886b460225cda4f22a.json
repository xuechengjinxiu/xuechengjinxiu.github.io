{"remainingRequest":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js??ref--13-0!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/seed.js","dependencies":[{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/seed.js","mtime":1585119550000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.object.freeze\";\nimport _classCallCheck from \"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport \"core-js/modules/es6.typed.uint32-array\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport CryptoJS from \"crypto-js\";\nimport base58 from \"base-58\";\nimport words from \"./word-list\";\nimport crypto from \"./crypto\";\nimport secure_random from \"./secure-random\";\nimport converters from \"./converters\"; // start generateNewSeed\n\nfunction generateNewSeed(length) {\n  var wordCount = words.length;\n  var random = generateRandomUint32Array(length);\n  var phrase = [];\n\n  for (var i = 0; i < length; i++) {\n    var wordIndex = random[i] % wordCount;\n    phrase.push(words[wordIndex]);\n  }\n\n  random.set(new Uint8Array(random.length));\n  return phrase.join(\" \");\n}\n\nfunction generateRandomUint32Array(length) {\n  var a = secure_random.randomUint8Array(length);\n  var b = secure_random.randomUint8Array(length);\n  var result = new Uint32Array(length);\n\n  for (var i = 0; i < length; i++) {\n    var hash = converters.byteArrayToHexString(sha256(\"\" + a[i] + b[i]));\n    var randomValue = parseInt(hash.slice(0, 13), 16);\n    result.set([randomValue], i);\n  }\n\n  return result;\n}\n\nfunction sha256(input) {\n  var bytes;\n\n  if (typeof input === \"string\") {\n    bytes = converters.stringToByteArray(input);\n  } else {\n    bytes = input;\n  }\n\n  var wordArray = converters.byteArrayToWordArrayEx(Uint8Array.from(bytes));\n  var resultWordArray = CryptoJS.SHA256(wordArray);\n  return converters.wordArrayToByteArrayEx(resultWordArray);\n} // encryptSeedPhrase\n\n\nfunction encryptSeedPhrase(seedPhrase, password, encryptionRounds) {\n  if (encryptionRounds === void 0) {\n    encryptionRounds = 5000;\n  }\n\n  if (encryptionRounds < 1000) {\n    console.warn(\"Encryption rounds may be too few\");\n  }\n\n  return crypto.encryptSeed(seedPhrase, password, encryptionRounds);\n} // decryptSeedPhrase\n\n\nfunction decryptSeedPhrase(encryptedSeedPhrase, password, encryptionRounds) {\n  if (encryptionRounds === void 0) {\n    encryptionRounds = 5000;\n  }\n\n  try {\n    var phrase = crypto.decryptSeed(encryptedSeedPhrase, password, encryptionRounds);\n    return phrase;\n  } catch (e) {\n    throw new Error(\"The password is wrong\");\n  }\n}\n\nexport default {\n  generateNewSeed: generateNewSeed,\n  encryptSeedPhrase: encryptSeedPhrase,\n  decryptSeedPhrase: decryptSeedPhrase\n};\nexport var Seed = function Seed(phrase, nonce, networkByte) {\n  _classCallCheck(this, Seed);\n\n  this.phrase = phrase;\n  this.nonce = nonce || 0; //WALLET NUMBER\n\n  var keys = crypto.buildKeyPair(phrase, this.nonce); //Produce publickey and privatekey\n\n  this.address = crypto.buildRawAddress(keys.publicKey, networkByte);\n  this.keyPair = {\n    privateKey: base58.encode(keys.privateKey),\n    publicKey: base58.encode(keys.publicKey)\n  };\n  Object.freeze(this);\n  Object.freeze(this.keyPair);\n};",null]}