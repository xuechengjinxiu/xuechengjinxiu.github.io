{"remainingRequest":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js??ref--13-0!/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/converters.js","dependencies":[{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/src/libs1/converters.js","mtime":1585119550000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jin/Desktop/v-cloud-feature-common-component/token-service/wallet/ui/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.typed.uint8-array\";\nimport \"core-js/modules/es6.typed.uint32-array\";\nimport \"core-js/modules/es6.regexp.to-string\";\n\n/** START OF THE LICENSED CODE */\n\n/******************************************************************************\n * Copyright Â© 2013-2016 The Nxt Core Developers.                             *\n *                                                                            *\n * See the AUTHORS.txt, DEVELOPER-AGREEMENT.txt and LICENSE.txt files at      *\n * the top-level directory of this distribution for the individual copyright  *\n * holder information and the developer policies on copyright and licensing.  *\n *                                                                            *\n * Unless otherwise agreed in a custom licensing agreement, no part of the    *\n * Nxt software, including this file, may be copied, modified, propagated,    *\n * or distributed except according to the terms contained in the LICENSE.txt  *\n * file.                                                                      *\n *                                                                            *\n * Removal or modification of this copyright notice is prohibited.            *\n *                                                                            *\n ******************************************************************************/\nimport CryptoJS from \"crypto-js\";\nvar charToNibble = {};\nvar nibbleToChar = [];\nvar i;\n\nfor (i = 0; i <= 9; ++i) {\n  var character = i.toString();\n  charToNibble[character] = i;\n  nibbleToChar.push(character);\n}\n\nfor (i = 10; i <= 15; ++i) {\n  var lowerChar = String.fromCharCode(\"a\".charCodeAt(0) + i - 10);\n  var upperChar = String.fromCharCode(\"A\".charCodeAt(0) + i - 10);\n  charToNibble[lowerChar] = i;\n  charToNibble[upperChar] = i;\n  nibbleToChar.push(lowerChar);\n}\n\nvar Converters = {\n  byteArrayToHexString: function byteArrayToHexString(bytes) {\n    var str = \"\";\n\n    for (var i_1 = 0; i_1 < bytes.length; ++i_1) {\n      if (bytes[i_1] < 0) {\n        bytes[i_1] += 256;\n      }\n\n      str += nibbleToChar[bytes[i_1] >> 4] + nibbleToChar[bytes[i_1] & 0x0f];\n    }\n\n    return str;\n  },\n  stringToByteArray: function stringToByteArray(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = new Array(str.length);\n\n    for (var i_2 = 0; i_2 < str.length; ++i_2) {\n      bytes[i_2] = str.charCodeAt(i_2);\n    }\n\n    return bytes;\n  },\n  hexStringToByteArray: function hexStringToByteArray(str) {\n    var bytes = [];\n    var i = 0;\n\n    if (0 !== str.length % 2) {\n      bytes.push(charToNibble[str.charAt(0)]);\n      ++i;\n    }\n\n    for (; i < str.length - 1; i += 2) {\n      bytes.push((charToNibble[str.charAt(i)] << 4) + charToNibble[str.charAt(i + 1)]);\n    }\n\n    return bytes;\n  },\n  stringToHexString: function stringToHexString(str) {\n    return this.byteArrayToHexString(this.stringToByteArray(str));\n  },\n  hexStringToString: function hexStringToString(hex) {\n    return this.byteArrayToString(this.hexStringToByteArray(hex));\n  },\n  checkBytesToIntInput: function checkBytesToIntInput(bytes, numBytes, opt_startIndex) {\n    var startIndex = opt_startIndex || 0;\n\n    if (startIndex < 0) {\n      throw new Error(\"Start index should not be negative\");\n    }\n\n    if (bytes.length < startIndex + numBytes) {\n      throw new Error(\"Need at least \" + numBytes + \" bytes to convert to an integer\");\n    }\n\n    return startIndex;\n  },\n  byteArrayToSignedShort: function byteArrayToSignedShort(bytes, opt_startIndex) {\n    var index = this.checkBytesToIntInput(bytes, 2, opt_startIndex);\n    var value = bytes[index];\n    value += bytes[index + 1] << 8;\n    return value;\n  },\n  byteArrayToSignedInt32: function byteArrayToSignedInt32(bytes, opt_startIndex) {\n    var index = this.checkBytesToIntInput(bytes, 4, opt_startIndex);\n    var value = bytes[index];\n    value += bytes[index + 1] << 8;\n    value += bytes[index + 2] << 16;\n    value += bytes[index + 3] << 24;\n    return value;\n  },\n  // create a wordArray that is Big-Endian\n  byteArrayToWordArray: function byteArrayToWordArray(byteArray) {\n    var i = 0,\n        offset = 0,\n        word = 0,\n        len = byteArray.length;\n    var words = new Uint32Array((len / 4 | 0) + (len % 4 == 0 ? 0 : 1));\n\n    while (i < len - len % 4) {\n      words[offset++] = byteArray[i++] << 24 | byteArray[i++] << 16 | byteArray[i++] << 8 | byteArray[i++];\n    }\n\n    if (len % 4 != 0) {\n      word = byteArray[i++] << 24;\n\n      if (len % 4 > 1) {\n        word = word | byteArray[i++] << 16;\n      }\n\n      if (len % 4 > 2) {\n        word = word | byteArray[i++] << 8;\n      }\n\n      words[offset] = word;\n    }\n\n    var wordArray = new Object();\n    wordArray.sigBytes = len;\n    wordArray.words = words;\n    return wordArray;\n  },\n  // assumes wordArray is Big-Endian\n  wordArrayToByteArray: function wordArrayToByteArray(wordArray) {\n    return Converters.wordArrayToByteArrayImpl(wordArray, true);\n  },\n  wordArrayToByteArrayImpl: function wordArrayToByteArrayImpl(wordArray, isFirstByteHasSign) {\n    var len = wordArray.words.length;\n\n    if (len == 0) {\n      return new Array(0);\n    }\n\n    var byteArray = new Array(wordArray.sigBytes);\n    var offset = 0,\n        word,\n        i;\n\n    for (i = 0; i < len - 1; i++) {\n      word = wordArray.words[i];\n      byteArray[offset++] = isFirstByteHasSign ? word >> 24 : word >> 24 & 0xff;\n      byteArray[offset++] = word >> 16 & 0xff;\n      byteArray[offset++] = word >> 8 & 0xff;\n      byteArray[offset++] = word & 0xff;\n    }\n\n    word = wordArray.words[len - 1];\n    byteArray[offset++] = isFirstByteHasSign ? word >> 24 : word >> 24 & 0xff;\n\n    if (wordArray.sigBytes % 4 == 0) {\n      byteArray[offset++] = word >> 16 & 0xff;\n      byteArray[offset++] = word >> 8 & 0xff;\n      byteArray[offset++] = word & 0xff;\n    }\n\n    if (wordArray.sigBytes % 4 > 1) {\n      byteArray[offset++] = word >> 16 & 0xff;\n    }\n\n    if (wordArray.sigBytes % 4 > 2) {\n      byteArray[offset++] = word >> 8 & 0xff;\n    }\n\n    return byteArray;\n  },\n  byteArrayToString: function byteArrayToString(bytes, opt_startIndex, length) {\n    if (length == 0) {\n      return \"\";\n    }\n\n    if (opt_startIndex && length) {\n      this.checkBytesToIntInput(bytes, parseInt(length, 10), parseInt(opt_startIndex, 10));\n      bytes = bytes.slice(opt_startIndex, opt_startIndex + length);\n    }\n\n    return decodeURIComponent(escape(String.fromCharCode.apply(null, bytes)));\n  },\n  byteArrayToShortArray: function byteArrayToShortArray(byteArray) {\n    var shortArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      shortArray[i] = byteArray[i * 2] | byteArray[i * 2 + 1] << 8;\n    }\n\n    return shortArray;\n  },\n  shortArrayToByteArray: function shortArrayToByteArray(shortArray) {\n    var byteArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      byteArray[2 * i] = shortArray[i] & 0xff;\n      byteArray[2 * i + 1] = shortArray[i] >> 8;\n    }\n\n    return byteArray;\n  },\n  shortArrayToHexString: function shortArrayToHexString(ary) {\n    var res = \"\";\n\n    for (var i_4 = 0; i_4 < ary.length; i_4++) {\n      res += nibbleToChar[ary[i_4] >> 4 & 0x0f] + nibbleToChar[ary[i_4] & 0x0f] + nibbleToChar[ary[i_4] >> 12 & 0x0f] + nibbleToChar[ary[i_4] >> 8 & 0x0f];\n    }\n\n    return res;\n  },\n\n  /**\n   * Produces an array of the specified number of bytes to represent the integer\n   * value. Default output encodes ints in little endian format. Handles signed\n   * as well as unsigned integers. Due to limitations in JavaScript's number\n   * format, x cannot be a true 64 bit integer (8 bytes).\n   */\n  intToBytes_: function intToBytes_(x, numBytes, unsignedMax, opt_bigEndian) {\n    var signedMax = Math.floor(unsignedMax / 2);\n    var negativeMax = (signedMax + 1) * -1;\n\n    if (x != Math.floor(x) || x < negativeMax || x > unsignedMax) {\n      throw new Error(x + \" is not a \" + numBytes * 8 + \" bit integer\");\n    }\n\n    var bytes = [];\n    var current; // Number type 0 is in the positive int range, 1 is larger than signed int,\n    // and 2 is negative int.\n\n    var numberType = x >= 0 && x <= signedMax ? 0 : x > signedMax && x <= unsignedMax ? 1 : 2;\n\n    if (numberType == 2) {\n      x = x * -1 - 1;\n    }\n\n    for (var i_5 = 0; i_5 < numBytes; i_5++) {\n      if (numberType == 2) {\n        current = 255 - x % 256;\n      } else {\n        current = x % 256;\n      }\n\n      if (opt_bigEndian) {\n        bytes.unshift(current);\n      } else {\n        bytes.push(current);\n      }\n\n      if (numberType == 1) {\n        x = Math.floor(x / 256);\n      } else {\n        x = x >> 8;\n      }\n    }\n\n    return bytes;\n  },\n  int32ToBytes: function int32ToBytes(x, opt_bigEndian) {\n    return Converters.intToBytes_(x, 4, 4294967295, opt_bigEndian);\n  },\n  int16ToBytes: function int16ToBytes(x, opt_bigEndian) {\n    return Converters.intToBytes_(x, 2, 65535, opt_bigEndian);\n  },\n\n  /**\n   * Based on https://groups.google.com/d/msg/crypto-js/TOb92tcJlU0/Eq7VZ5tpi-QJ\n   * Converts a word array to a Uint8Array.\n   * @param {WordArray} wordArray The word array.\n   * @return {Uint8Array} The Uint8Array.\n   */\n  wordArrayToByteArrayEx: function wordArrayToByteArrayEx(wordArray) {\n    // Shortcuts\n    var words = wordArray.words;\n    var sigBytes = wordArray.sigBytes; // Convert\n\n    var u8 = new Uint8Array(sigBytes);\n\n    for (var i_6 = 0; i_6 < sigBytes; i_6++) {\n      var byte = words[i_6 >>> 2] >>> 24 - i_6 % 4 * 8 & 0xff;\n      u8[i_6] = byte;\n    }\n\n    return u8;\n  },\n\n  /**\n   * Converts a Uint8Array to a word array.\n   * @param {string} u8Str The Uint8Array.\n   * @return {WordArray} The word array.\n   */\n  byteArrayToWordArrayEx: function byteArrayToWordArrayEx(u8arr) {\n    // Shortcut\n    var len = u8arr.length; // Convert\n\n    var words = [];\n\n    for (var i_7 = 0; i_7 < len; i_7++) {\n      words[i_7 >>> 2] |= (u8arr[i_7] & 0xff) << 24 - i_7 % 4 * 8;\n    }\n\n    return CryptoJS.lib.WordArray.create(words, len);\n  }\n};\nexport default Converters;",null]}