/* @preserve
 * qrcode-decoder 0.1.1 (https://github.com/yugasun/qrcode-decoder)
 * API https://github.com/yugasun/qrcode-decoder/blob/master/doc/api.md
 * Copyright 2017-2019 yugasun. All Rights Reserved
 * Licensed under MIT (https://github.com/yugasun/qrcode-decoder/blob/master/LICENSE)
 */

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('babel-polyfill');
var jsQR = _interopDefault(require('jsqr'));

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
/* eslint-disable no-underscore-dangle */

var QrcodeDecoder = function () {
    /**
     * Constructor for QrcodeDecoder
     */
    function QrcodeDecoder() {
        _classCallCheck(this, QrcodeDecoder);

        this.timerCapture = null;
        this.canvasElem = null;
        this.gCtx = null;
        this.stream = null;
        this.videoElem = null;
        this.getUserMediaHandler = null;
        this.videoConstraints = { video: true, audio: false };

        this.defaultOption = { inversionAttempts: 'attemptBoth' };
    }

    /**
     * Verifies if canvas element is supported.
     */
    /* eslint-disable class-methods-use-this */


    _createClass(QrcodeDecoder, [{
        key: 'isCanvasSupported',
        value: function isCanvasSupported() {
            var elem = document.createElement('canvas');
            return !!(elem.getContext && elem.getContext('2d'));
        }

        /**
         * draw lint
         *
         * @param {object} begin line begin point
         * @param {object} end line end point
         * @param {string} color color string
         */
        // _drawLine(begin, end, color) {
        //     this.gCtx.beginPath();
        //     this.gCtx.moveTo(begin.x, begin.y);
        //     this.gCtx.lineTo(end.x, end.y);
        //     this.gCtx.lineWidth = 4;
        //     this.gCtx.strokeStyle = color;
        //     this.gCtx.stroke();
        // }

        /**
         * create qrcode marker
         *
         * @param {object} code jsqr parse code object
         */
        // _createQrcodeMark(code) {
        //     this._drawLine(
        //         code.location.topLeftCorner,
        //         code.location.topRightCorner,
        //         '#FF3B58',
        //     );
        //     this._drawLine(
        //         code.location.topRightCorner,
        //         code.location.bottomRightCorner,
        //         '#FF3B58',
        //     );
        //     this._drawLine(
        //         code.location.bottomRightCorner,
        //         code.location.bottomLeftCorner,
        //         '#FF3B58',
        //     );
        //     this._drawLine(
        //         code.location.bottomLeftCorner,
        //         code.location.topLeftCorner,
        //         '#FF3B58',
        //     );
        // }

    }, {
        key: '_createImageData',
        value: function _createImageData(target, width, height) {
            if (!this.canvasElem) {
                this._prepareCanvas(width, height);
            }

            this.gCtx.clearRect(0, 0, width, height);
            this.gCtx.drawImage(target, 0, 0, width, height);

            var imageData = this.gCtx.getImageData(0, 0, this.canvasElem.width, this.canvasElem.height);

            return imageData;
        }

        /**
         * Prepares the canvas element (which will
         * receive the image from the camera and provide
         * what the algorithm needs for checking for a
         * QRCode and then decoding it.)
         *
         *
         * @param  {DOMElement} canvasElem the canvas
         *                                 element
         * @param  {number} width      The width that
         *                             the canvas element
         *                             should have
         * @param  {number} height     The height that
         *                             the canvas element
         *                             should have
         * @return {DOMElement}            the canvas
         * after the resize if width and height
         * provided.
         */

    }, {
        key: '_prepareCanvas',
        value: function _prepareCanvas(width, height) {
            if (!this.canvasElem) {
                this.canvasElem = document.createElement('canvas');
                this.canvasElem.style.width = width + 'px';
                this.canvasElem.style.height = height + 'px';
                this.canvasElem.width = width;
                this.canvasElem.height = height;
            }

            this.gCtx = this.canvasElem.getContext('2d');
        }

        /**
         * Based on the video dimensions and the canvas
         * that was previously generated captures the
         * video/image source and then paints into the
         * canvas so that the decoder is able to work as
         * it expects.
         * @param  {DOMElement} videoElem <video> dom element
         * @param  {Object} options     options (optional) - Additional options.
         *  inversionAttempts - (attemptBoth (default), dontInvert, onlyInvert, or invertFirst)
         *  refer to jsqr options: https://github.com/cozmo/jsQR
         */

    }, {
        key: '_captureToCanvas',
        value: function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(videoElem, options) {
                var _this = this;

                var proms, result;
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if (this.timerCapture) {
                                    clearTimeout(this.timerCapture);
                                }

                                proms = function proms() {
                                    var p = new Promise(function () {
                                        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(resolve) {
                                            var code, imageData;
                                            return regeneratorRuntime.wrap(function _callee3$(_context3) {
                                                while (1) {
                                                    switch (_context3.prev = _context3.next) {
                                                        case 0:
                                                            code = void 0;

                                                            if (videoElem.videoWidth && videoElem.videoHeight) {
                                                                imageData = _this._createImageData(videoElem, videoElem.videoWidth, videoElem.videoHeight);


                                                                code = jsQR(imageData.data, imageData.width, imageData.height, options);

                                                                if (code) {
                                                                    resolve(code);
                                                                } else {
                                                                    _this.timerCapture = setTimeout(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                                                                        return regeneratorRuntime.wrap(function _callee$(_context) {
                                                                            while (1) {
                                                                                switch (_context.prev = _context.next) {
                                                                                    case 0:
                                                                                        _context.next = 2;
                                                                                        return _this._captureToCanvas(videoElem, options);

                                                                                    case 2:
                                                                                        code = _context.sent;

                                                                                        resolve(code);

                                                                                    case 4:
                                                                                    case 'end':
                                                                                        return _context.stop();
                                                                                }
                                                                            }
                                                                        }, _callee, _this);
                                                                    })), 500);
                                                                }
                                                            } else {
                                                                _this.timerCapture = setTimeout(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                                                                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                                                                        while (1) {
                                                                            switch (_context2.prev = _context2.next) {
                                                                                case 0:
                                                                                    _context2.next = 2;
                                                                                    return _this._captureToCanvas(videoElem, options);

                                                                                case 2:
                                                                                    code = _context2.sent;

                                                                                    resolve(code);

                                                                                case 4:
                                                                                case 'end':
                                                                                    return _context2.stop();
                                                                            }
                                                                        }
                                                                    }, _callee2, _this);
                                                                })), 500);
                                                            }

                                                        case 2:
                                                        case 'end':
                                                            return _context3.stop();
                                                    }
                                                }
                                            }, _callee3, _this);
                                        }));

                                        return function (_x3) {
                                            return _ref2.apply(this, arguments);
                                        };
                                    }());

                                    return p;
                                };

                                _context4.next = 4;
                                return proms();

                            case 4:
                                result = _context4.sent;
                                return _context4.abrupt('return', result);

                            case 6:
                            case 'end':
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function _captureToCanvas(_x, _x2) {
                return _ref.apply(this, arguments);
            }

            return _captureToCanvas;
        }()

        /**
         * Prepares the video element for receiving
         * camera's input. Releases a stream if there
         * was any (resets).
         *
         * @param  {DOMElement} videoElem <video> dom element
         * @param  {Object} options     options (optional) - Additional options.
         *  inversionAttempts - (attemptBoth (default), dontInvert, onlyInvert, or invertFirst)
         *  refer to jsqr options: https://github.com/cozmo/jsQR
         */

    }, {
        key: 'decodeFromCamera',
        value: function () {
            var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(videoElem) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var opts, stream, code;
                return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                opts = _extends({}, this.defaultOption, options);


                                this.stop();

                                if (navigator.mediaDevices.getUserMedia) {
                                    _context5.next = 4;
                                    break;
                                }

                                throw new Error("Couldn't get video from camera");

                            case 4:
                                _context5.prev = 4;
                                _context5.next = 7;
                                return navigator.mediaDevices.getUserMedia(this.videoConstraints);

                            case 7:
                                stream = _context5.sent;

                                videoElem.srcObject = stream;
                                // videoElem.src = window.URL.createObjectURL(stream);
                                this.videoElem = videoElem;
                                this.stream = stream;
                                this.videoDimensions = false;

                                _context5.next = 14;
                                return this.decodeFromVideo(videoElem, opts);

                            case 14:
                                code = _context5.sent;
                                return _context5.abrupt('return', code);

                            case 18:
                                _context5.prev = 18;
                                _context5.t0 = _context5['catch'](4);
                                throw _context5.t0;

                            case 21:
                            case 'end':
                                return _context5.stop();
                        }
                    }
                }, _callee5, this, [[4, 18]]);
            }));

            function decodeFromCamera(_x4) {
                return _ref5.apply(this, arguments);
            }

            return decodeFromCamera;
        }()

        /**
         * Prepares the video element for video file.
         *
         * @param  {DOMElement} videoElem <video> dom element
         * @param  {Object} options     options (optional) - Additional options.
         *  inversionAttempts - (attemptBoth (default), dontInvert, onlyInvert, or invertFirst)
         *  refer to jsqr options: https://github.com/cozmo/jsQR
         */

    }, {
        key: 'decodeFromVideo',
        value: function () {
            var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(videoElem) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var opts, code;
                return regeneratorRuntime.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                opts = _extends({}, this.defaultOption, options);
                                _context6.prev = 1;

                                this.videoElem = videoElem;
                                _context6.next = 5;
                                return this._captureToCanvas(videoElem, opts);

                            case 5:
                                code = _context6.sent;
                                return _context6.abrupt('return', code);

                            case 9:
                                _context6.prev = 9;
                                _context6.t0 = _context6['catch'](1);
                                throw _context6.t0;

                            case 12:
                            case 'end':
                                return _context6.stop();
                        }
                    }
                }, _callee6, this, [[1, 9]]);
            }));

            function decodeFromVideo(_x6) {
                return _ref6.apply(this, arguments);
            }

            return decodeFromVideo;
        }()

        /**
         * Decodes an image from its src.
         * @param  {DOMElement} imageElem
         * @param  {Object} options     options (optional) - Additional options.
         *  inversionAttempts - (attemptBoth (default), dontInvert, onlyInvert, or invertFirst)
         *  refer to jsqr options: https://github.com/cozmo/jsQR
         */

    }, {
        key: 'decodeFromImage',
        value: function () {
            var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(img) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var imgDom, opts, proms, code;
                return regeneratorRuntime.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                imgDom = void 0;
                                opts = _extends({}, this.defaultOption, options);

                                if (!(+img.nodeType > 0)) {
                                    _context7.next = 8;
                                    break;
                                }

                                if (img.src) {
                                    _context7.next = 5;
                                    break;
                                }

                                throw new Error('The ImageElement must contain a src');

                            case 5:
                                imgDom = img;
                                _context7.next = 15;
                                break;

                            case 8:
                                if (!(typeof img === 'string')) {
                                    _context7.next = 15;
                                    break;
                                }

                                imgDom = document.createElement('img');
                                imgDom.src = img;
                                if (options.crossOrigin) {
                                    imgDom.crossOrigin = options.crossOrigin;
                                }

                                proms = function proms() {
                                    return new Promise(function (resolve) {
                                        imgDom.onload = function () {
                                            return resolve(true);
                                        };
                                    });
                                };

                                _context7.next = 15;
                                return proms();

                            case 15:
                                code = false;

                                if (imgDom) {
                                    code = this._decodeFromImageElm(imgDom, opts);
                                }
                                return _context7.abrupt('return', code);

                            case 18:
                            case 'end':
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));

            function decodeFromImage(_x8) {
                return _ref7.apply(this, arguments);
            }

            return decodeFromImage;
        }()
    }, {
        key: '_decodeFromImageElm',
        value: function _decodeFromImageElm(imgObj) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var opts = _extends({}, this.defaultOption, options);
            var imageData = this._createImageData(imgObj, imgObj.width, imgObj.height);

            var code = jsQR(imageData.data, imageData.width, imageData.height, opts);

            if (code) {
                return code;
            }

            return false;
        }

        /**
         * Releases a video stream that was being
         * captured by prepareToVideo
         */

    }, {
        key: 'stop',
        value: function stop() {
            if (this.stream) {
                var track = this.stream.getTracks()[0];
                track.stop();
                this.stream = undefined;

                // fix: clear black bg after camera capture
                this.videoElem.srcObject = null;
            }

            if (this.timerCapture) {
                clearTimeout(this.timerCapture);
                this.timerCapture = undefined;
            }

            return this;
        }

        /**
         * Sets the sourceId for the camera to use.
         *
         * The sourceId can be found using the
         * getVideoSources function on a browser that
         * supports it (currently only Chrome).
         *
         * @param {String} sourceId     The id of the
         * video source you want to use (or false to use
         * the current default)
         */

    }, {
        key: 'setSourceId',
        value: function setSourceId(sourceId) {
            if (sourceId) {
                this.videoConstraints.video = {
                    optional: [{ sourceId: sourceId }]
                };
            } else {
                this.videoConstraints.video = true;
            }

            return this;
        }

        /**
         * Gets a list of all available video sources on
         * the current device.
         * @param {Function} cb callback to be resolved
         * with error (first param) ou results (second
         * param) - a list containing all of the sources
         * that are of the 'video' kind.
         */

    }, {
        key: 'getVideoSources',
        value: function getVideoSources() {
            var sources = [];

            if (!(MediaStreamTrack && MediaStreamTrack.getSources)) {
                throw new Error('Current browser doest not support MediaStreamTrack.getSources');
            }

            MediaStreamTrack.getSources(function (sourceInfos) {
                sourceInfos.forEach(function (sourceInfo) {
                    if (sourceInfo.kind === 'video') {
                        sources.push(sourceInfo);
                    }
                });
            });
            return sources;
        }
    }]);

    return QrcodeDecoder;
}();

module.exports = QrcodeDecoder;
